---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{get-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(unhcrdataportal)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/flat_full.Rmd: do not edit by hand -->

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->


<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 


<!--

# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->


 

This package include only one function called `odp`. The function is then made available through a shinyApp.

Beyond the function, this vignette is an opportunity to demonstrate how to turn an initial script into a package as the original idea came from from this `script`: 

__Why is it worth documenting your function as package?__

According to [chatGPT](https://chat.openai.com/share/1d1ab05a-53e4-4643-adeb-9f64ad926bbe), Documenting R functions as packages provides several benefits:

 * __Reproducibility and Maintainability__: Packages encapsulate the code, data, and documentation required to perform a specific task or provide a set of functionalities. By documenting your R functions within a package, you ensure that the code is self-contained and can be easily shared and reproduced by others. This helps maintain the integrity of your code and simplifies the process of maintaining and updating it over time.

 * __Ease of Use__: Documenting your functions within a package allows you to provide clear and comprehensive documentation, including details about the function's purpose, arguments, return values, and usage examples. This makes it easier for other users (including yourself in the future) to understand how to use your functions effectively. Well-documented packages increase the discoverability and accessibility of your code, making it more likely to be adopted and utilized by others.

 * __Collaboration and Community Contribution__: By creating a package with documented functions, you can encourage collaboration within the R community. Others can easily install and use your package, providing feedback, suggesting improvements, and even contributing their own enhancements or bug fixes. Documentation is crucial for enabling others to understand your codebase and contribute effectively, fostering an active and vibrant community around your package.

 * __Versioning and Dependency Management__: Documenting your R functions within a package allows you to manage versioning and dependencies more effectively. Packages can specify the version requirements for other packages they rely on, ensuring that users have the correct versions installed to avoid compatibility issues. This helps maintain the reproducibility of your code across different environments and simplifies the process of managing package dependencies.

 * __Integration with R Ecosystem__: Packaging your functions makes it easier to integrate them with other tools and libraries in the R ecosystem. R packages can leverage existing packages and take advantage of their functionality, creating a more cohesive and interconnected ecosystem. By documenting your functions within a package, you contribute to this ecosystem and enable seamless integration with other tools and workflows.


Overall, documenting R functions within a package brings structure, reproducibility, ease of use, collaboration opportunities, and integration capabilities. It enhances the accessibility, maintainability, and adoption potential of your code, benefiting both yourself and the wider R community.


# odp

What does it take to turn a script into a documented package?

 *  Install [FUSEN](https://thinkr-open.github.io/fusen/) package  
 
 *  Start a project as a FUSEN   
 
 * document the [0-dev_history.Rmd]() to initialize the package   
 
 * during the process associate it with a github  repostory that you have created  
 
 * get into the function and prefix all the function with package they comes from - while doing this document them as `@importFrom`  
 
 * document the function parameters  `@param`  
 
 * review the function and insert comments within the script to explain what you are doing in the script - actually chatGPT is quite effective to help you doing this  
 
 * then go to the chunk examples - and document examples. Make sure you document your example and link them to practical use cases. Assumes that your target users has little knowledge of the context  
 
 * then set up a few unit testing - actually chatGPT is quite effective to help you doing this  
 
 * inflate your fusen markdown  
 
 * add a global file with the following 
    # remotes::install_github("thinkr-open/checkhelper")
   `checkhelper::print_globals()`

 
 * review your readme.Rmd and inject back there your business use cases  
 
 * build the companion website for the documentation with `pkgdown::build_site()`  
 
 * push back everything to github  

Et voila... 


<!--
Create a chunk for the core of the function

- The chunk needs to be named `function` at least
- It contains the code of a documented function
- The chunk can also be named `function-my_median` to make it easily
findable in your Rmd
- Let the `@examples` part empty, and use the next `examples` chunk instead to present reproducible examples

After inflating the template

-  This function code will automatically be added in a new file in the "R/" directory
-->


<!--
Create a chunk with an example of use for your function

- The chunk needs to be named `examples` at least
- It contains working examples of your function
- The chunk is better be named `examples-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This example will automatically be added in the '@examples' part of our function above in the "R/" directory
- This example will automatically be added in the vignette created from this Rmd template
-->


 

```{r example-odp}
## Use as

## odp(): to retrieve an overview of all available situation pages
data <- odp() |> 
         dplyr::filter(page_type =="situation" )

DT::datatable(data |> dplyr::select( page_name,page_url),
              options = list(scrollX = TRUE))

## to retrieve the datasets for a specific country /situation
 
datasit <- odp(page = "Sudan situation")
# display results.. 
DT::datatable(datasit,
              options = list(scrollX = TRUE))

## to retrieve a specific dataset on the given page as a parsed JSON
# odp(page, dataset)
page <- "Sudan situation"
dataset <- "population"

datasitpop <- odp(page = page,
               dataset = dataset) |> 
  ## extract the data
  purrr::map( "data") |>
  ## Bind together in a data frame
  purrr::list_rbind()

## plotting quickly the results... 
library(ggplot2)
datasitpop |>
  ggplot() +
  geom_col(aes(x = as.integer(individuals),
               y = reorder( glue::glue("{population_group_name} \n as of {date}"), 
                                        as.integer(individuals) )),
           fill = unhcrthemes::unhcr_pal(n = 1, "pal_blue"),
           width = 0.8) +
  labs(title = paste0(page),
       x = "Number of people",
       y = "",
       caption = "Source: https://data.unhcr.org/en/situations \n
                   Â© UNHCR, The UN Refugee Agency") +
  scale_x_continuous(expand = expansion(c(0, 0.1)),
                     breaks = scales::pretty_breaks(n = 7),
                     labels = scales::label_number(scale_cut = scales::cut_short_scale())) +
  unhcrthemes::theme_unhcr(
              font_size = 12,
              grid = "X",
              axis = "y")
```

<!--
Create a chunk with a test of use for your function

- The chunk needs to be named `tests` at least
- It contains working tests of your function
- The chunk is better be named `tests-my_median` to be handled
correctly when inflated as a vignette

After inflating the template

-  This test code will automatically be added in the "tests/testthat/" directory
-->


# run_app

if you want to widen your package audience, make your function available through a web interface so that users can avoid rstudio desktop installation :

 * create a Shiny App function called `run_app()` that will display some interactivity around your function  
 
 * Set up a launcher `app.R` script at the root of the package  
 
 * Use the launcher to deploy it to UNHCR rstudio server: http://rstudio.unhcr.org   
 

    

  

```{r example-run_app}

## Run the shiny App 
# run_app()
```

  

  

<!--

# Inflate your package

You're one inflate from paper to box.
Build your package from this very Rmd using `fusen::inflate()`

- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory
-->


